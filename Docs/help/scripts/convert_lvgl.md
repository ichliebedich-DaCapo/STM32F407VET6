# lvgl初始化代码转换脚本
> `目的`：把GUI Guider生成的初始化代码快速转换为自定义格式的C++链式调用初始化代码。
> 除了自动定义、声明组件外，还可以去除一些不必要的初始化（组件自创建起就有的属性）
> 
>`注意事项`：使用该脚本时应使用3.8以上的python解释器，其次根据下面提示来在指定位置修改，
> 虽然代码组织较清晰，注释较为详细，但由于代码较为庞大，且是基本面向过程编程，
> 理解上容易混乱，建议在指定位置处修改，切莫随便修改，否则牵一发而动全身

## 1. 脚本使用说明
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
把脚本往下滑动到底部，可以看到如下代码.在find_c_functions函数中，可以指定搜索路径、搜索文件和搜索函数，
它会自动对指定路径下指定文件处的指定函数进行解析，把函数名、函数形参表（暂时没用上）和函数体返回。
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
然后按着如注释描述的步骤执行，在注释“# 添加版本信息钩子”下，可以根据需求修改版本信息，或者添加别的钩子函数，
钩子函数目前有5种，前4种是在代码中组件定义前、组件定义后、组件初始化前和组件初始化后添加一些信息，
第五种是完成代码初始化后输出在控制台的信息
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
在注释“# 执行生成”下，可以看到模式mode=GenerateMode.OVERWRITE，这个可以指定生成模式，有覆写、追加等。
当然，目前还啥都没做。
```python
# -------------------------------------主函数--------------------------------------------
def main():
    # 【定位屏幕初始化代码】：定位 setup_scr_* 函数,并获取工程名和函数体
    c_content = find_c_functions(search_path="../Projects/driversDevelop/ui/generated",
                           func_name="setup_scr_*",
                           file_name="setup_scr_*.c")
    # 获取第一个满足条件的函数
    setup_scr_function = c_content[0]
    # 获取函数体和屏幕名称
    screen_name = extract_screen_name(setup_scr_function[0])
    func_body = setup_scr_function[2]
    # 添加屏幕组件关系
    add_widget_relations(screen_name)

    # 【提取代码行】：从setup_scr_*函数体代码提取出代码行
    code_lines = extract_c_code_lines(func_body)

    # 【处理代码行】：从每行代码里提取到组件初始化信息和组件关系
    process_code_lines(code_lines)

    # 【解析信息】：把组件信息解析为对应的代码，并输出
    widgets_init_code,widgets_define_code = iterate_widgets(screen_name)

    # 【输出代码文件】：把组件相关代码信息，按照特定格式写入文件中
    generator = TemplateGenerator()

    # 添加版本信息钩子
    generator.hooks.add_hook('pre_define',  lambda: f"// Generated by Fairy on {datetime.now():%Y-%m-%d  %H:%M}\n")

    # 执行生成
    generator.generate(
        define_blocks=widgets_define_code,
        init_blocks=widgets_init_code,
        output_path=".",
        mode=GenerateMode.OVERWRITE
    )

    print("代码生成成功！输出文件：ui.cpp")
```


## 2，映射表
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
为了按照一定规则生成指定格式的代码，这里定义了映射表（规则表）和对应的解析器。它们主要是解析函数用的，
从功能角度来说，有解析创建函数、属性设置函数、样式转换函数三种。
### `创建函数规则`
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
这是为了把原组件定义转为自定义组件对象的规则，很好理解，遇到lv_label_create就知道要创建标签组件了。
那么就把它定义为Label的实例化对象。在右边的值可以看到，列表里有两个元素，左边的是组件对象名的前缀，
右边是组件定义时的类型。
```python
def get_widget_info(create_line):
    """
    匹配代码行对应的组件类型
    :param create_line: lv_xxx_create函数所在代码行
    :return:
    """
    widget_map = {
        "lv_obj_create": ["obj", 'Component'],
        "lv_imagebutton_create": ["imgbtn", 'ImageButton'],
        "lv_label_create": ["label", 'Label'],
        "lv_image_create": ["img", 'Image'],
        "lv_button_create": ["btn", 'Button'],
        "lv_checkbox_create": ['chekcbox', 'CheckBox'],
    }
```

### `属性设置函数规则`
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
搜索变量“function_handlers”，可以看到下面结构，注释很详细。在里面添加函数键，就可以制定相应规则。
- `args_map`是存放缺省参数的,并且是从后往前，
比如原函数“lv_imagebutton_set_src(ui->blueCounter_minus, LV_IMAGEBUTTON_STATE_RELEASED, &_btn_RGB565A8_65x65, NULL, NULL);”
最右边两个参数在将要生成的链式调用函数src里可以省略（因为有默认值）
- `method_map`是存放函数名映射规则的，简单来说就是根据解析得到的函数名和参数表来确定生成什么样的函数
- `index`是确定哪些参数能决定改变生成的函数名method，单映射的情况下，handler为None即可。
比如这里，如果形参表里的第一个参数是LV_IMAGEBUTTON_STATE_RELEASED，那么就生成released_src函数
- `default`是默认生成的函数名，确保不满足特殊条件时默认转换的函数名
- `type`是参数类型，如果为None，表示参数全缺省即可免去调用
- `handler`是对前面函数名映射规则的补充，前面只是单个参数决定最终生成的函数名是什么，但实际情况可能更复杂，
需要自定义lambda，虽然现在还没遇到这种情况。
```python
function_handlers = {
    # 图像按钮
    'lv_imagebutton_set_src': {
        # 参数缺省映射表，由专门的函数进行重载解析，最后返回参数列表。如果无参就返回None
        'args_map': ['NULL', 'NULL'],
        'method_map': {
            # 确定哪些参数能决定改变method，单映射的情况下，handler为None即可
            'index': [1],
            # 映射表可以为空，映射之后这个参数就要去掉，因为我的目的是简化
            'mapping': {
                'LV_IMAGEBUTTON_STATE_RELEASED': 'released_src',
                'LV_IMAGEBUTTON_STATE_PRESSED': 'pressed_src',
                'LV_IMAGEBUTTON_STATE_CHECKED_RELEASED': 'checked_released_src',
                'LV_IMAGEBUTTON_STATE_CHECKED_PRESSED': 'checked_pressed_src',
            },
            # 类型为None表示参数全缺省即可免去调用，不为None表示不缺省就省略（这个优先级是高于args_map为空的）。
            'type': '',
            # method默认在映射表里去找，如果找不到就用默认值
            'default': 'src',
            # 单参数可以自定一个lambda，多参数处理时，必须要自定一个lambda，用于返回处理的结果。
            # 输入的参数是索引(或者处理过的参数)、参数表和mapping，需要返回一个判断结果（以None为标志）和一个最终处理的函数名和参数表
            # 事实上，更复杂的的需求不可能依靠lambda来完成，但是现在并没有遇到情况，就先用lambda代替
            'handler': None
        },
    },
    # …………
}
```

### `样式转换函数规则`
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
样式函数转换规则的出现是为了减轻初始化函数转换的负担，因为样式函数都是清一色的三参数零返回值的函数，
并且函数名也极有规律。如果使用前面的属性设置函数的规则，那么这个字典就会设置得异常庞大，
何况样式函数没什么特别的转换规则。
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
这些转换规则是定义在变量default_config里的，每个列表里的第一个参数是指定的函数名，第二个参数是默认值，满足就不调用了。
第三个参数是函数简写（可选），一般默认转换函数时会去除前面的lv_obj_set_style前缀。

```python
def convert_style_calls(func_name, args):
    """
    转换样式代码
    :param func_name:
    :param args:
    :return: converted(string) 返回的是转换好的样式代码，如果不需要那么就返回None
    """
    # 每个列表都有2~3个元素，左边是匹配的函数名（相当于键），第二个元素是默认值（为''表示没有），第三个元素是函数的简写（如果有的话）
    default_config = [
        ['border_width', "0"],
        ['text_color', 'lv_color_hex(0xffffff)'],
        ['text_opa', "255"],
        ['text_font', '', 'font'],
        ['text_line_space', "0"],
        ['text_align', 'LV_TEXT_ALIGN_CENTER'],
        ['bg_opa', "255"],
        ['pad_top', "0"],
        ['pad_right', "0"],
        ['pad_bottom', "0"],
        ['pad_left', "0"],
        ['shadow_width', "0"],
        ['image_recolor_opa', '255'],
        ['image_opa', '255'],
        ['text_letter_space', '0', 'letter_space']
    ]
```