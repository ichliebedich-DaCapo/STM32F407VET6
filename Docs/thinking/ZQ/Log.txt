2025.2.11二
【】：
    推己及人

2025.2.9日
【GUI】：
    1，现在既没有发生问题，代码也没膨胀，也能成功内联，真棒！(当然，我还没有正式使用链式调用）
    Memory region         Used Size  Region Size  %age Used
              CCMRAM:         56 KB        64 KB     87.50%
                 RAM:       46104 B       128 KB     35.17%
               FLASH:      386464 B       512 KB     73.71%

2025.2.8六
【GUI】：
    1，哈哈嗨，我又回来了。我想到怎么解决该死的组件定义问题了，它是没有struct，但它还有namespace，
    namespace完全可以作为ui的引导者、组织者。正经的来说，我可以在GUI_Base.hpp里定义一个UI命名空间，
    在里面再定义一个Interface类作为外部的交互接口，再声明一个函数用于初始化屏幕，可以放到ui.cpp里去实现
    然后再定义一个widgets命名空间来存放各种组件。这个命名空间可以继续定义一个main空间，
    里面先定义一个screen组件，作为main屏幕的实体。这样就可以在ui.hpp里光明正大地引用GUI_Base头文件，
    GUI.hpp里也可以光明正大引用GUI_Base头文件。ui.cpp只要考虑实现屏幕初始化函数就行，考虑得就少了。


2025.2.7五
【静态库链接】：
    1，这该死的依赖关系，真他宝贝折磨。越理越乱，还需要作出各种取舍
    2，先记住下面这个占用，避免后面越搞越大
    Memory region         Used Size  Region Size  %age Used
              CCMRAM:         56 KB        64 KB     87.50%
                 RAM:       46108 B       128 KB     35.18%
               FLASH:      386212 B       512 KB     73.66%

【安排】
    1，静态库链接无法使用LTO的事情，有时间我再处理。AI那个有空我再处理
    2，明天先修复模拟器，然后考虑LVGL设计。等这一切都做好了，再把以前的工程全部整理一遍

2025.2.6四
【GUI】：
    1，lvgl就应该使用更高级的语言比如C++来封装，把一些高频调用封装起来，这样开发会方便很多，不使用图形化工具的情况下。
    使用C++的话，那些组件又得重写，这次吸收了前面的经验，除了使用面向对象开发外，还应使用元编程+CRTP的模式实现链式调用，
    确保开销小又方便调用。
    2，不使用图形化工具开发界面的情况下，命令式的开发要抓，声明式开发也要搞。这些都是C++的情况下搞的，声明式开发，
    我看后面还是需要标签语言来搞，脚本化开发还是可以试试的。前面那个链式调用还是必要的，即便是图形化设计工具，
    也并不能随时随地处理一些特殊情况，比如与事件相关的一些编写，使用链式调用明显比纯C效率要高一些。
    3，之所以前面不考虑图形化工具下的交互逻辑，是因为交互逻辑使用图形化工具开发实际上并不怎么方便，因为无法使用驱动，
    且很难在图形化工具里实现复杂的逻辑，简单的逻辑依靠CLion强大的代码补全功能很容易做的。虽然说前后端分离，
    但实际工程中却没那么好做。

【bootloader】：
    1，我看这个东西迟早也得搞上

【安排】：
    1，明天还是把静态库链接搞定，然后再把模拟器恢复。然后让jy测试，看看能否使用，如果可以使用，我再优化GUI库，
    避免全盘崩溃。因为我身边没有板子，无法亲自验证。

2025.2.5三
【思路】：
    1，使用cmake配置头文件过程中，感觉这个stm32f4xx_hal_conf不够智能，智能纯手动，这就很受限了。只有把依赖厘清，让它自动生成头文件即可，
    嗯没错，这样省得忘记取消宏的注释
    2，我突然想到一个问题，既然我选择是否包含资源文件来控制是否编译，那么是不是意味着我不用一个一个添加该死的宏了？
    3，有些地方是免不了这个该死的宏，比如ISR里的中断定义

2025.2.4二
1，今天开始正常进行项目重构，规范一下项目架构。原因，暑假就得电赛了，考虑到嵌入式Linux只有我一人能负责，四天三夜的效率就太低了，而且板型不一定能用。
尤其是比赛后要发代码到邮箱里，uboot、linux和根文件系统加在一块都几个G了，不太合适吧。
只能在STM32里尽可能发挥，把整个项目重构一遍，增加一些自动脚本进去，尽可能快速开发。

2，驱动开发用纯C写，这是大方向